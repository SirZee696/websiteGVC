<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Screen Coordinate System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .gradient-text {
            background: linear-gradient(to right, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        canvas {
            cursor: crosshair;
            touch-action: none; /* Prevents scrolling on touch devices */
        }
        .highlight-box {
             box-shadow: 0 0 0 2px #3b82f6, 0 0 15px -3px #3b82f6;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-300 antialiased">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <!-- Header -->
        <header class="text-center mb-8 md:mb-12">
            <h1 class="text-4xl md:text-5xl font-bold tracking-tight text-white">Understanding the</h1>
            <h2 class="text-4xl md:text-5xl font-bold tracking-tight gradient-text">Screen Coordinate System</h2>
            <p class="mt-4 max-w-2xl mx-auto text-slate-400">An interactive guide to how computers map pixels on your screen.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 lg:gap-12 items-start">
            <!-- Left Column: Interactive Canvas -->
            <div class="bg-slate-800 rounded-xl shadow-2xl overflow-hidden aspect-square lg:aspect-auto lg:h-full flex flex-col">
                <div id="canvas-container" class="relative w-full h-full flex-grow">
                     <canvas id="screenCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
                </div>
                <div class="bg-slate-950/50 p-4 border-t border-slate-700 space-y-3">
                    <div class="flex items-center gap-4 px-2">
                        <label for="resolutionSlider" class="text-sm font-mono whitespace-nowrap text-slate-400">Resolution:</label>
                        <input id="resolutionSlider" type="range" min="32" max="512" value="256" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                        <span id="resolutionValue" class="text-sm font-mono text-slate-400 w-24 text-right">256x256</span>
                    </div>
                    <p class="text-center text-sm font-mono" id="coord-display">Hover over the grid! (X: ?, Y: ?)</p>
                </div>
            </div>

            <!-- Right Column: Explanation -->
            <div class="space-y-6 text-base md:text-lg">
                <div class="bg-slate-800 p-6 rounded-xl shadow-lg transition-all duration-300 hover:bg-slate-700/50" id="explanation-1">
                    <h3 class="font-bold text-xl text-white mb-2 flex items-center">
                        <span class="bg-blue-500 text-white rounded-full h-6 w-6 text-sm font-bold flex items-center justify-center mr-3">1</span>
                        The Origin (0, 0)
                    </h3>
                    <p>Unlike a standard Cartesian graph, a screen's coordinate system starts at the <strong class="text-blue-400">top-left corner</strong>. This point is called the origin and has the coordinate <strong class="text-blue-400">(0, 0)</strong>. Every other pixel on the screen is measured from this starting point.</p>
                </div>

                <div class="bg-slate-800 p-6 rounded-xl shadow-lg transition-all duration-300 hover:bg-slate-700/50" id="explanation-2">
                    <h3 class="font-bold text-xl text-white mb-2 flex items-center">
                        <span class="bg-purple-500 text-white rounded-full h-6 w-6 text-sm font-bold flex items-center justify-center mr-3">2</span>
                        The Axes
                    </h3>
                    <p>The <strong class="text-purple-400">X-axis</strong> runs horizontally. As you move to the right, the X value increases. The <strong class="text-purple-400">Y-axis</strong> runs vertically, but it's inverted! As you move <strong class="text-purple-400">down</strong>, the Y value increases. This is a key difference from mathematical graphs where Y increases upwards.</p>
                </div>

                <div class="bg-slate-800 p-6 rounded-xl shadow-lg transition-all duration-300 hover:bg-slate-700/50" id="explanation-3">
                    <h3 class="font-bold text-xl text-white mb-2 flex items-center">
                        <span class="bg-emerald-500 text-white rounded-full h-6 w-6 text-sm font-bold flex items-center justify-center mr-3">3</span>
                        Pixels as Coordinates
                    </h3>
                    <p>Your screen is a grid of tiny lights called pixels. Each pixel has a unique <strong class="text-emerald-400">(X, Y)</strong> coordinate, which are always whole numbers (integers). There's no such thing as half a pixel! The point on the grid represents one of these pixels. <strong class="text-emerald-400">Try dragging it!</strong></p>
                </div>
            </div>
        </div>
    </div>

    <div class="text-center my-8 md:my-12">
        <a href="index.html" class="bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-300 inline-flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
            Back to Hub
        </a>
    </div>

    <script>
        const canvas = document.getElementById('screenCanvas');
        const container = document.getElementById('canvas-container');
        const ctx = canvas.getContext('2d');
        const coordDisplay = document.getElementById('coord-display');
        const resolutionSlider = document.getElementById('resolutionSlider');
        const resolutionValueDisplay = document.getElementById('resolutionValue');

        // --- Configuration ---
        const gridSize = 20; // Grid size is now a fixed value
        const gridColor = 'rgba(255, 255, 255, 0.1)';
        const axisColor = 'rgba(255, 255, 255, 0.3)';
        const pointColor = '#3b82f6'; // blue-500
        const pointRadius = 10;

        let width, height; // These now refer to the canvas's internal resolution
        let point = { x: 0, y: 0 };
        let isDragging = false;
        let isInitialLoad = true;
        
        // --- Explanation Highlighters ---
        const explanation1 = document.getElementById('explanation-1');
        const explanation2 = document.getElementById('explanation-2');
        const explanation3 = document.getElementById('explanation-3');
        const allExplanations = [explanation1, explanation2, explanation3];

        function highlightExplanation(el) {
            allExplanations.forEach(e => e.classList.remove('highlight-box'));
            if (el) {
                el.classList.add('highlight-box');
            }
        }

        // --- Canvas Drawing ---
        function resizeCanvas() {
            // This function now only handles the CSS display size of the canvas
            // to match its container when the window is resized.
            // The actual pixel resolution is handled by updateResolution().
            canvas.style.width = `${container.clientWidth}px`;
            canvas.style.height = `${container.clientHeight}px`;
            updateResolution();
        }

        function drawGrid() {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;

            for (let x = 0; x <= width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            for (let y = 0; y <= height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }

        function drawAxes() {
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;

            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, 1);
            ctx.lineTo(width, 1);
            ctx.stroke();

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(1, 0);
            ctx.lineTo(1, height);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = axisColor;
            ctx.font = '14px Inter';
            ctx.textAlign = 'left';
            ctx.fillText('X increases →', 10, 20);
            
            ctx.save();
            ctx.translate(20, 45);
            ctx.rotate(Math.PI / 2);
            ctx.fillText('Y increases →', 0, 0);
            ctx.restore();
        }

        function drawPoint(p) {
            ctx.fillStyle = pointColor;
            ctx.beginPath();
            ctx.arc(p.x, p.y, pointRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Point label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`(${p.x}, ${p.y})`, p.x, p.y);
        }

        function draw() {
            // Disable image smoothing to make low-resolution pixels sharp and clear
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();
            drawPoint(point);
        }

        function updateResolution() {
            const newWidth = parseInt(resolutionSlider.value, 10);
            
            // Use the container's client rect for a stable aspect ratio calculation
            const containerRect = container.getBoundingClientRect();
            // Prevent division by zero if container is not rendered yet
            const aspectRatio = containerRect.width > 0 ? containerRect.height / containerRect.width : 1;
            const newHeight = Math.floor(newWidth * aspectRatio);

            // Update the canvas's internal resolution (the actual number of pixels)
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // Update global variables that track the canvas's internal dimensions
            width = newWidth;
            height = newHeight;

            // Update the text display to show the new resolution
            resolutionValueDisplay.textContent = `${newWidth}x${newHeight}`;

            // On the very first run, position the point relative to the new size.
            if (isInitialLoad) {
                point = { x: Math.floor(width / 4), y: Math.floor(height / 4) };
                isInitialLoad = false;
            }

            // Clamp the point's position to be within the new bounds after resizing
            point.x = Math.max(0, Math.min(width, point.x));
            point.y = Math.max(0, Math.min(height, point.y));
            
            draw();
        }

        // --- Interactivity ---
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const cssX = evt.clientX - rect.left;
            const cssY = evt.clientY - rect.top;

            // Scale CSS coordinates (the visible size) to canvas coordinates (the internal resolution)
            const canvasX = Math.round(cssX * (canvas.width / rect.width));
            const canvasY = Math.round(cssY * (canvas.height / rect.height));

            return { x: canvasX, y: canvasY };
        }
        
        function getTouchPos(evt) {
            const rect = canvas.getBoundingClientRect();
            const touch = evt.touches[0];
            const cssX = touch.clientX - rect.left;
            const cssY = touch.clientY - rect.top;

            // Scale CSS coordinates (the visible size) to canvas coordinates (the internal resolution)
            const canvasX = Math.round(cssX * (canvas.width / rect.width));
            const canvasY = Math.round(cssY * (canvas.height / rect.height));

            return { x: canvasX, y: canvasY };
        }


        function handleMouseMove(evt) {
            const pos = getMousePos(evt);
            coordDisplay.textContent = `Live Coordinates -> (X: ${pos.x}, Y: ${pos.y})`;
            
            if (pos.x < 50 && pos.y < 50) highlightExplanation(explanation1);
            else if (pos.x > width * 0.7 || pos.y > height * 0.7) highlightExplanation(explanation2);
            else highlightExplanation(null);

            if (isDragging) {
                point.x = Math.max(0, Math.min(width, pos.x));
                point.y = Math.max(0, Math.min(height, pos.y));
                highlightExplanation(explanation3);
                draw();
            }
        }
        
        function handleMouseDown(evt) {
            const pos = getMousePos(evt);
            const dx = pos.x - point.x;
            const dy = pos.y - point.y;
            if (Math.sqrt(dx * dx + dy * dy) < pointRadius * 2) { // Increased hit area
                isDragging = true;
            }
        }
        
        function handleMouseUp() {
            isDragging = false;
        }

        // Touch event handlers
        function handleTouchStart(evt) {
             evt.preventDefault();
            const pos = getTouchPos(evt);
             const dx = pos.x - point.x;
            const dy = pos.y - point.y;
            if (Math.sqrt(dx * dx + dy * dy) < pointRadius * 3) { // Even larger hit area for touch
                isDragging = true;
            }
        }

        function handleTouchMove(evt) {
            evt.preventDefault();
            const pos = getTouchPos(evt);
            coordDisplay.textContent = `Live Coordinates -> (X: ${pos.x}, Y: ${pos.y})`;
             if (isDragging) {
                point.x = Math.max(0, Math.min(width, pos.x));
                point.y = Math.max(0, Math.min(height, pos.y));
                highlightExplanation(explanation3);
                draw();
            }
        }

        function handleTouchEnd() {
            isDragging = false;
        }

        // --- Event Listeners ---
        resolutionSlider.addEventListener('input', updateResolution);

        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('mouseup', handleMouseUp); // Listen on window to catch drags outside canvas
        
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        window.addEventListener('touchend', handleTouchEnd);


        window.addEventListener('resize', resizeCanvas);

        // Initial setup
        resizeCanvas();
    </script>
</body>
</html>



