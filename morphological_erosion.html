<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morphological Erosion – Interactive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .canvas-container { position: relative; display: inline-block; }
    </style>
    <meta name="description" content="Interactive visualization of morphological erosion with adjustable structuring elements, size, and iterations.">
</head>
<body class="bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 text-white min-h-screen">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold bg-gradient-to-r from-gray-200 to-gray-400 bg-clip-text text-transparent">
                Morphological Erosion
            </h1>
            <p class="mt-4 text-lg text-slate-300 max-w-3xl mx-auto">
                Erosion shrinks bright structures by replacing each pixel with the minimum value under a structuring element.
                It is used to remove small noise, disconnect thin bridges, and thin shapes.
            </p>
        </header>

        <!-- Educational Section -->
        <section class="mb-8 bg-slate-800/50 backdrop-blur-sm rounded-2xl p-6 border border-slate-700">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div>
                    <h2 class="text-2xl font-semibold text-sky-300 mb-4">How It Works</h2>
                    <div class="space-y-4 text-slate-300">
                        <p>
                            For grayscale images, erosion with structuring element \(S\) computes
                            \[\mathrm{Result}(x,y) = \min\limits_{(i,j) \in S}\, \mathrm{Image}(x+i, y+j).\]
                            For binary images, a pixel remains white only if the structuring element
                            fits entirely within the foreground.
                        </p>
                        <div class="bg-slate-900/70 p-4 rounded-lg border border-slate-600">
                            <h3 class="text-lg font-medium text-slate-200 mb-2">Parameters</h3>
                            <ul class="list-disc list-inside space-y-1 text-slate-300">
                                <li><span class="font-semibold">Structuring Element</span>: shape (square, cross, disk)</li>
                                <li><span class="font-semibold">Size</span>: controls radius/half-width</li>
                                <li><span class="font-semibold">Iterations</span>: apply erosion repeatedly</li>
                                <li><span class="font-semibold">Binarize</span>: threshold before erosion for binary morphology</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div>
                    <h2 class="text-2xl font-semibold text-emerald-300 mb-4">Common Uses</h2>
                    <div class="space-y-3 text-slate-300">
                        <div class="flex items-start space-x-3">
                            <div class="w-2 h-2 bg-emerald-300 rounded-full mt-2 flex-shrink-0"></div>
                            <p><strong>Denoising:</strong> Remove isolated bright speckles.</p>
                        </div>
                        <div class="flex items-start space-x-3">
                            <div class="w-2 h-2 bg-blue-300 rounded-full mt-2 flex-shrink-0"></div>
                            <p><strong>Separation:</strong> Break thin connections between nearby objects.</p>
                        </div>
                        <div class="flex items-start space-x-3">
                            <div class="w-2 h-2 bg-purple-300 rounded-full mt-2 flex-shrink-0"></div>
                            <p><strong>Skeletonization step:</strong> Used within pipelines that thin shapes.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Controls and Previews -->
        <section class="mb-8">
            <div class="grid grid-cols-1 xl:grid-cols-3 gap-8">
                <!-- Controls + Kernel Preview -->
                <div class="bg-slate-800/50 backdrop-blur-sm rounded-2xl p-6 border border-slate-700">
                    <h3 class="text-xl font-semibold text-cyan-300 mb-4">Structuring Element</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-slate-300 mb-2">Shape</label>
                            <select id="seShape" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white">
                                <option value="square">Square</option>
                                <option value="cross">Cross</option>
                                <option value="disk">Disk</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-slate-300 mb-2">Size: <span id="sizeVal" class="font-mono">3</span></label>
                            <input id="seSize" type="range" min="1" max="5" step="2" value="3" class="w-full accent-cyan-500 cursor-pointer">
                            <p class="text-xs text-slate-400 mt-1">Odd values only (1,3,5,...)</p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-slate-300 mb-2">Iterations: <span id="iterVal" class="font-mono">1</span></label>
                            <input id="seIterations" type="range" min="1" max="3" step="1" value="1" class="w-full accent-cyan-500 cursor-pointer">
                        </div>
                        <div class="mt-4">
                            <h4 class="text-sm font-semibold text-slate-200 mb-2">SE Preview</h4>
                            <div class="canvas-container">
                                <canvas id="kernelCanvas" width="220" height="220" class="border-2 border-slate-600 rounded-lg bg-slate-900"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Interactive Demonstration Grid -->
                <div class="bg-slate-800/50 backdrop-blur-sm rounded-2xl p-6 border border-slate-700 flex flex-col items-center xl:col-span-2">
                    <div class="flex items-center justify-between mb-4 w-full">
                        <h3 class="text-xl font-semibold text-cyan-400">Interactive Demonstration</h3>
                        <div class="flex space-x-2">
                            <button id="applyErosion" class="px-3 py-1 bg-cyan-600 hover:bg-cyan-700 rounded text-sm transition-colors">Apply Erosion</button>
                            <button id="resetGrid" class="px-3 py-1 bg-slate-600 hover:bg-slate-700 rounded text-sm transition-colors">Reset Grid</button>
                        </div>
                    </div>
                    <div class="flex flex-col md:flex-row gap-6">
                        <div class="flex flex-col items-center">
                            <h4 class="text-lg font-semibold text-slate-300 mb-2">Input Grid</h4>
                            <div class="canvas-container">
                                <canvas id="demoCanvas" width="330" height="330" class="border-2 border-slate-600 rounded-lg cursor-pointer"></canvas>
                            </div>
                        </div>
                        <div class="flex flex-col items-center">
                            <h4 class="text-lg font-semibold text-cyan-300 mb-2">Result Grid</h4>
                            <div class="canvas-container">
                                <canvas id="resultDemoCanvas" width="330" height="330" class="border-2 border-cyan-500 rounded-lg"></canvas>
                            </div>
                        </div>
                    </div>
                    <p class="mt-3 text-sm text-slate-400 text-center">
                        Hover over the Input Grid to see a single erosion step. Click to toggle pixels.
                        <br>The center pixel is eroded (darkened) if the SE doesn't fit.
                    </p>
                </div>
            </div>
        </section>

        <!-- Back Button -->
        <div class="text-center">
            <button onclick="history.back()" class="bg-slate-700 hover:bg-slate-800 text-white font-bold py-3 px-8 rounded-lg transition-all duration-300 shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                ← Back to Gallery
            </button>
        </div>

    </div>

    <script>
        // Kernel preview canvas
        const kernelCanvas = document.getElementById('kernelCanvas');
        const kctx = kernelCanvas.getContext('2d');

        // Demo canvas
        const demoCanvas = document.getElementById('demoCanvas');
        const dctx = demoCanvas.getContext('2d');
        const resultDemoCanvas = document.getElementById('resultDemoCanvas');
        const rdctx = resultDemoCanvas.getContext('2d');

        // Controls
        const seShape = document.getElementById('seShape');
        const seSize = document.getElementById('seSize');
        const sizeVal = document.getElementById('sizeVal');
        const seIterations = document.getElementById('seIterations');
        const iterVal = document.getElementById('iterVal');
        const applyErosion = document.getElementById('applyErosion');
        const resetGrid = document.getElementById('resetGrid');

        function buildKernel(shape, size) {
            const r = Math.floor(size / 2);
            const ker = [];
            for (let j = -r; j <= r; j++) {
                for (let i = -r; i <= r; i++) {
                    let keep = false;
                    if (shape === 'square') keep = true;
                    else if (shape === 'cross') keep = (i === 0 || j === 0);
                    else if (shape === 'disk') keep = (i*i + j*j) <= r*r + 0.0001;
                    if (keep) ker.push({dx: i, dy: j});
                }
            }
            return { r, ker };
        }

        // --- Demo Grid Logic ---
        const GRID_SIZE = 15;
        const CELL_SIZE = demoCanvas.width / GRID_SIZE;
        let gridState = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
        let originalGridState = null; // To store the user-drawn pattern
        let hoverPos = null;

        function initDemoGrid() {
            // Create a default shape
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    // Make a thick 'L' shape
                    if ((x >= 3 && x <= 5 && y >= 3 && y < 12) || (y >= 9 && y <= 11 && x >= 3 && x < 10)) {
                        gridState[y][x] = 1;
                    } else {
                        gridState[y][x] = 0;
                    }
                }
            }
            originalGridState = JSON.parse(JSON.stringify(gridState)); // Deep copy
            drawDemoGrid();
            drawResultGrid(gridState);
        }

        function erodeGridOnce(inputGrid) {
            const newGrid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            const size = parseInt(seSize.value, 10);
            const { ker } = buildKernel(seShape.value, size);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    let fits = true;
                    for (const k of ker) {
                        const kx = x + k.dx;
                        const ky = y + k.dy;
                        if (kx < 0 || kx >= GRID_SIZE || ky < 0 || ky >= GRID_SIZE || inputGrid[ky][kx] === 0) {
                            fits = false;
                            break;
                        }
                    }
                    newGrid[y][x] = (inputGrid[y][x] && fits) ? 1 : 0;
                }
            }
            return newGrid;
        }

        function drawResultGrid(state) {
            rdctx.fillStyle = '#0f172a'; // slate-900
            rdctx.fillRect(0, 0, resultDemoCanvas.width, resultDemoCanvas.height);

            // Draw base grid cells
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    rdctx.fillStyle = state[y][x] ? '#e2e8f0' : '#1e293b'; // slate-200 / slate-800
                    rdctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                }
            }
        }

        function drawDemoGrid(gridForCheck) {
            const checkGrid = gridForCheck || gridState;

            dctx.fillStyle = '#0f172a'; // slate-900
            dctx.fillRect(0, 0, demoCanvas.width, demoCanvas.height);

            // Draw base grid cells
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    dctx.fillStyle = gridState[y][x] ? '#e2e8f0' : '#1e293b'; // slate-200 / slate-800
                    dctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                }
            }

            if (hoverPos) {
                const size = parseInt(seSize.value, 10);
                const { r, ker } = buildKernel(seShape.value, size);
                const hx = hoverPos.x;
                const hy = hoverPos.y;

                let fits = true;

                // Draw SE overlay and check for erosion
                for (const k of ker) {
                    const kx = hx + k.dx;
                    const ky = hy + k.dy;

                    if (kx >= 0 && kx < GRID_SIZE && ky >= 0 && ky < GRID_SIZE) {
                        // Check if the SE fits
                        if (checkGrid[ky][kx] === 0) {
                            fits = false;
                        }
                        // Draw SE overlay
                        dctx.fillStyle = 'rgba(34, 211, 238, 0.5)'; // cyan-400 with alpha
                        dctx.fillRect(kx * CELL_SIZE, ky * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    } else {
                        // SE is off the grid, so it doesn't fit
                        fits = false;
                    }
                }

                // Draw SE origin
                dctx.strokeStyle = '#eab308'; // amber-400
                dctx.lineWidth = 2;
                dctx.strokeRect(hx * CELL_SIZE + 1, hy * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);

                // Show erosion result
                const resultColor = (checkGrid[hy][hx] && fits) ? '#e2e8f0' : '#1e293b';
                dctx.fillStyle = resultColor;
                dctx.globalAlpha = 0.7;
                dctx.fillRect(hx * CELL_SIZE + 1, hy * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                dctx.globalAlpha = 1.0;

                // Add a marker to show the result
                dctx.strokeStyle = fits ? '#10b981' : '#f43f5e'; // emerald-500 or rose-600
                dctx.lineWidth = 3;
                dctx.strokeRect(hx * CELL_SIZE, hy * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }

        demoCanvas.addEventListener('mousemove', (e) => {
            const rect = demoCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const gridX = Math.floor(mouseX / CELL_SIZE);
            const gridY = Math.floor(mouseY / CELL_SIZE);

            if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                if (!hoverPos || hoverPos.x !== gridX || hoverPos.y !== gridY) {
                    hoverPos = { x: gridX, y: gridY };
                    drawDemoGrid();
                }
            } else {
                hoverPos = null;
                drawDemoGrid();
            }
        });

        demoCanvas.addEventListener('mouseleave', () => {
            hoverPos = null;
            drawDemoGrid();
        });

        demoCanvas.addEventListener('click', (e) => {
            const rect = demoCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const gridX = Math.floor(mouseX / CELL_SIZE);
            const gridY = Math.floor(mouseY / CELL_SIZE);

            if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                gridState[gridY][gridX] = 1 - gridState[gridY][gridX]; // Toggle 0 and 1
                originalGridState[gridY][gridX] = gridState[gridY][gridX]; // Update the original state too
                drawResultGrid(gridState);
                drawDemoGrid();
            }
        });

        applyErosion.addEventListener('click', async () => {
            // Disable controls during animation
            const controlsToToggle = [applyErosion, resetGrid, seShape, seSize, seIterations, demoCanvas];
            controlsToToggle.forEach(el => el.disabled = true);
            demoCanvas.style.cursor = 'wait';

            const iterations = parseInt(seIterations.value, 10);
            let currentGrid = JSON.parse(JSON.stringify(originalGridState)); // Start from original

            for (let iter = 0; iter < iterations; iter++) {
                const nextGrid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));

                // Before starting the animation, ensure the result grid shows the current state
                drawResultGrid(currentGrid);
                await new Promise(r => setTimeout(r, 100)); // Small pause to show the starting state

                // Animate the traversal for one iteration
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        hoverPos = { x, y };
                        drawDemoGrid(currentGrid); // This will show the SE at the current (x,y)

                        // Perform the erosion check for the current pixel
                        const size = parseInt(seSize.value, 10);
                        const { ker } = buildKernel(seShape.value, size);
                        let fits = true;
                        for (const k of ker) {
                            const kx = x + k.dx;
                            const ky = y + k.dy;
                            if (kx < 0 || kx >= GRID_SIZE || ky < 0 || ky >= GRID_SIZE || currentGrid[ky][kx] === 0) {
                                fits = false;
                                break;
                            }
                        }
                        const newPixelValue = (currentGrid[y][x] && fits) ? 1 : 0;
                        nextGrid[y][x] = newPixelValue;

                        // Update the result grid in real-time for the current pixel
                        rdctx.fillStyle = newPixelValue ? '#e2e8f0' : '#1e293b'; // slate-200 / slate-800
                        rdctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);

                        await new Promise(r => setTimeout(r, 50)); // Increased delay for animation
                    }
                }
                currentGrid = nextGrid; // Update the grid state for the next iteration

                if (iter < iterations - 1) {
                    await new Promise(r => setTimeout(r, 400)); // Pause between iterations
                }
            }
            controlsToToggle.forEach(el => el.disabled = false);
            demoCanvas.style.cursor = 'pointer';
            // Final cleanup draw
            hoverPos = null;
            drawDemoGrid(); // Redraw with original state and no hover
        });

        resetGrid.addEventListener('click', () => {
            gridState = JSON.parse(JSON.stringify(originalGridState));
            drawResultGrid(gridState);
            drawDemoGrid();
        });

        function renderKernel() {
            const size = parseInt(seSize.value, 10);
            const { r } = buildKernel(seShape.value, size);
            const cells = (r * 2) + 1;
            const pad = 10;
            const cellSize = Math.floor((kernelCanvas.width - pad * 2) / cells);
            // clear
            kctx.fillStyle = '#0f172a';
            kctx.fillRect(0, 0, kernelCanvas.width, kernelCanvas.height);

            // grid and fill
            for (let y = -r; y <= r; y++) {
                for (let x = -r; x <= r; x++) {
                    const cx = pad + (x + r) * cellSize;
                    const cy = pad + (y + r) * cellSize;
                    // cell bg
                    kctx.fillStyle = '#1f2937';
                    kctx.fillRect(cx, cy, cellSize - 2, cellSize - 2);
                    // decide if in SE
                    let inSE = false;
                    if (seShape.value === 'square') inSE = true;
                    else if (seShape.value === 'cross') inSE = (x === 0 || y === 0);
                    else if (seShape.value === 'disk') inSE = (x*x + y*y) <= r*r + 0.0001;
                    if (inSE) {
                        kctx.fillStyle = '#22d3ee';
                        kctx.fillRect(cx + 3, cy + 3, cellSize - 8, cellSize - 8);
                    }
                }
            }
            // center mark
            kctx.strokeStyle = '#eab308';
            kctx.lineWidth = 2;
            const ccx = pad + r * cellSize;
            const ccy = pad + r * cellSize;
            kctx.strokeRect(ccx + 1, ccy + 1, cellSize - 4, cellSize - 4);
        }

        seSize.addEventListener('input', () => { sizeVal.textContent = seSize.value; renderKernel(); drawDemoGrid(); });
        seShape.addEventListener('change', () => { renderKernel(); drawDemoGrid(); });
        seIterations.addEventListener('input', () => { iterVal.textContent = seIterations.value; });

        // Initialize
        initDemoGrid();
        renderKernel();
    </script>

</body>
</html>
