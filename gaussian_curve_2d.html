<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Curve 2D – Interactive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        #canvas-container {
            min-height: 500px;
            height: 100%;
        }
    </style>
    <meta name="description" content="Interactive visualization of the 2D Gaussian curve, the foundation for Gaussian blur kernels in image processing.">
</head>
<body class="bg-gradient-to-br from-slate-900 via-violet-900 to-slate-900 text-white min-h-screen flex items-center justify-center p-4">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl bg-slate-800/50 backdrop-blur-sm rounded-2xl border border-slate-700">
        
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold bg-gradient-to-r from-violet-300 to-purple-400 bg-clip-text text-transparent">
                Gaussian Curve 2D Form
            </h1>
            <p class="mt-4 text-lg text-slate-300 max-w-3xl mx-auto">
                This visualization shows the 2D Gaussian function, which forms a surface. In image processing, this surface is sampled to create a convolution kernel for Gaussian blur.
            </p>
        </header>

        <!-- Main Content -->
        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Side: Explanation & Controls -->
            <div class="lg:col-span-1 space-y-6">
                <div class="bg-slate-900/70 p-4 rounded-lg border border-slate-600">
                    <h2 class="text-2xl font-semibold text-sky-300 mb-3">The 2D Formula</h2>
                    <p class="text-center text-lg font-mono text-cyan-300">
                        G(x, y) = (1/(2π<span id="formula-sigma-1" class="text-yellow-300 font-bold">σ</span>²)) * e<sup>-((x²+y²)/(2<span id="formula-sigma-2" class="text-yellow-300 font-bold">σ</span>²))</sup>
                    </p>
                    <ul class="mt-4 space-y-2 text-sm text-slate-300 border-t border-slate-700 pt-3">
                        <li><strong class="text-white font-mono">G(x, y)</strong>: The height of the surface at point (x, y).</li>
                        <li><strong class="text-white font-mono">x, y</strong>: The coordinates on the 2D plane relative to the center.</li>
                        <li><strong class="text-white font-mono">σ (Sigma)</strong>: The standard deviation, controlling the "spread".</li>
                        <li><strong class="text-white font-mono">e</strong>: Euler's number (~2.718), the base of the natural logarithm.</li>
                    </ul>
                </div>

                <div class="bg-slate-900/70 p-4 rounded-lg border border-slate-600">
                    <h2 class="text-2xl font-semibold text-emerald-300 mb-3">The Key Parameter</h2>
                    <ul class="space-y-3 text-slate-300">
                        <li>
                            <strong class="text-white">Standard Deviation (σ):</strong> This single value controls the "spread" or width of the bell shape in all directions. A larger sigma results in a wider, gentler blur, while a smaller sigma creates a sharper, more concentrated effect.
                        </li>
                    </ul>
                </div>

                <!-- Controls -->
                <div class="bg-slate-900/70 p-4 rounded-lg border border-slate-600 space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-slate-300 mb-2">Standard Deviation (σ): <span id="sigmaVal" class="font-mono">15.0</span></label>
                        <input id="sigmaSlider" type="range" min="1" max="50" step="0.5" value="15" class="w-full accent-violet-500 cursor-pointer">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-300 mb-2">Axis Size: <span id="axisSizeVal" class="font-mono">4</span></label>
                        <input id="axisSizeSlider" type="range" min="2" max="10" step="2" value="4" class="w-full accent-violet-500 cursor-pointer">
                    </div>
                    <div class="pt-4 border-t border-slate-700">
                        <h4 class="text-sm font-semibold text-slate-200 mb-2 text-center">2D Kernel Heatmap</h4>
                        <div class="flex justify-center">
                            <canvas id="kernelCanvas" width="120" height="120" class="border-2 border-slate-600 rounded-lg bg-slate-900"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Side: Canvas -->
            <div class="lg:col-span-2 flex flex-col items-center justify-center bg-slate-900 rounded-lg border-2 border-slate-700 p-2">
                <div id="canvas-container" class="w-full h-full"></div>
                <p class="text-sm text-slate-400 mt-2">
                    Click and drag to rotate. Scroll to zoom. The height and color represent the value of the Gaussian function.
                </p>
            </div>
        </main>

        <!-- Back Button -->
        <div class="text-center mt-8">
            <button onclick="history.back()" class="bg-slate-700 hover:bg-slate-800 text-white font-bold py-3 px-8 rounded-lg transition-all duration-300 shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                ← Back to Gallery
            </button>
        </div>

    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // --- DOM Elements ---
        const container = document.getElementById('canvas-container');
        const sigmaSlider = document.getElementById('sigmaSlider');
        const sigmaVal = document.getElementById('sigmaVal');
        const axisSizeSlider = document.getElementById('axisSizeSlider');
        const axisSizeVal = document.getElementById('axisSizeVal');
        const kernelCanvas = document.getElementById('kernelCanvas');
        const kCtx = kernelCanvas.getContext('2d');

        // Formula elements
        const formulaSigma1 = document.getElementById('formula-sigma-1');
        const formulaSigma2 = document.getElementById('formula-sigma-2');

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(1.5, 1.5, 1.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- Grid Helper ---
        let gridHelper = new THREE.GridHelper(4, 20, '#475569', '#334155'); // slate-600, slate-700
        gridHelper.position.y = 0.001; // Slightly offset to prevent z-fighting with the plane
        scene.add(gridHelper);

        // --- 3D Surface ---
        let size = 4;
        const segments = 100;
        let geometry = new THREE.PlaneGeometry(size, size, segments, segments);
        const material = new THREE.MeshBasicMaterial({
            color: 0xa78bfa, // A nice violet color
            wireframe: true,
            side: THREE.DoubleSide,
        });
        const plane = new THREE.Mesh(geometry, material);
        plane.rotation.x = -Math.PI / 2; // Rotate to be flat on XZ plane
        scene.add(plane);

        // Store original vertex positions to modify Z
        let originalPositions = geometry.attributes.position.clone();

        // --- Axes Labels & Grid Values ---
        let labelGroup = new THREE.Group();
        scene.add(labelGroup);
        const fontLoader = new FontLoader();
        let font;
        fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.164.0/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
            font = loadedFont;
            updateLabels(); // Initial label draw
        });

        function updateLabels() {
            if (!font) return;

            // Clear old labels
            while(labelGroup.children.length > 0){ 
                labelGroup.remove(labelGroup.children[0]); 
            }

            const textMaterial = new THREE.MeshBasicMaterial({ color: 0x9ca3af });
            const halfSize = size / 2;
            const gridLabelOffset = halfSize + 0.1;
            const axisLabelOffset = halfSize + 0.2;

            // Grid value labels
            const valueTextParams = { font: font, size: 0.1, height: 0.01 };
            for (let i = -halfSize; i <= halfSize; i++) {
                if (i === 0) continue;
                const xValueGeo = new TextGeometry(i.toString(), valueTextParams);
                const xValueMesh = new THREE.Mesh(xValueGeo, textMaterial);
                xValueMesh.position.set(i - 0.05, 0, gridLabelOffset);
                labelGroup.add(xValueMesh);

                const yValueGeo = new TextGeometry(i.toString(), valueTextParams);
                const yValueMesh = new THREE.Mesh(yValueGeo, textMaterial);
                yValueMesh.position.set(gridLabelOffset, 0, i - 0.05);
                labelGroup.add(yValueMesh);
            }

            // Main axis labels
            const axisTextParams = { font: font, size: 0.15, height: 0.01 };
            const xGeo = new TextGeometry('X', axisTextParams);
            const xMesh = new THREE.Mesh(xGeo, textMaterial);
            xMesh.position.set(axisLabelOffset, 0, 0);
            labelGroup.add(xMesh);

            const yGeo = new TextGeometry('Y', axisTextParams);
            const yMesh = new THREE.Mesh(yGeo, textMaterial);
            yMesh.position.set(0, 0, axisLabelOffset);
            labelGroup.add(yMesh);

            const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x9ca3af });
            const zAxisPoints = [new THREE.Vector3(-halfSize, 0, -halfSize), new THREE.Vector3(-halfSize, 1.2, -halfSize)];
            const zAxisGeometry = new THREE.BufferGeometry().setFromPoints(zAxisPoints);
            const zAxisLine = new THREE.Line(zAxisGeometry, zAxisMaterial);
            labelGroup.add(zAxisLine);

            const zGeo = new TextGeometry('Z', axisTextParams);
            const zMesh = new THREE.Mesh(zGeo, textMaterial);
            zMesh.position.set(-halfSize + 0.1, 1.1, -halfSize - 0.2);
            labelGroup.add(zMesh);
        }

        // --- Gaussian Function ---
        function gaussian2D(x, y, sigma) {
            const sigmaSq = sigma * sigma;
            if (sigmaSq === 0) return 0;
            const exponent = -(x * x + y * y) / (2 * sigmaSq);
            return Math.exp(exponent); // Coefficient is ignored for shape visualization
        }

        // --- Kernel Preview Logic ---
        function drawKernelPreview(sigma) {
            const size = 15; // A fixed size for the preview kernel
            const r = Math.floor(size / 2);
            const kernel = Array(size).fill(0).map(() => Array(size).fill(0));
            let maxVal = 0;

            for (let y = -r; y <= r; y++) {
                for (let x = -r; x <= r; x++) {
                    const value = gaussian2D(x, y, sigma / 5); // Scale sigma for preview
                    kernel[y + r][x + r] = value;
                    if (value > maxVal) maxVal = value;
                }
            }

            kCtx.fillStyle = '#0f172a';
            kCtx.fillRect(0, 0, kernelCanvas.width, kernelCanvas.height);
            const cellSize = kernelCanvas.width / size;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const intensity = Math.round((kernel[y][x] / maxVal) * 255);
                    kCtx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                    kCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        // --- Update Logic ---
        function updateSurface() {
            const sigma = parseFloat(sigmaSlider.value);
            sigmaVal.textContent = sigma.toFixed(1);
            axisSizeVal.textContent = size;

            // Update live formula values
            formulaSigma1.textContent = sigma.toFixed(1);
            formulaSigma2.textContent = sigma.toFixed(1);

            // Update wireframe color based on sigma
            const minSigma = parseFloat(sigmaSlider.min);
            const maxSigma = parseFloat(sigmaSlider.max);
            const normalizedSigma = (sigma - minSigma) / (maxSigma - minSigma);
            // Transition from blue (low sigma, hue=0.66) to red (high sigma, hue=0.0)
            material.color.setHSL(0.66 - (normalizedSigma * 0.66), 1.0, 0.6);

            const positions = plane.geometry.attributes.position;

            for (let i = 0; i < positions.count; i++) {
                const x = originalPositions.getX(i);
                const y = originalPositions.getY(i); // This is Z in our rotated plane

                const height = gaussian2D(x, y, sigma / (10 / (size/4)) ); // Scale sigma relative to axis size
                positions.setZ(i, height);
            }

            positions.needsUpdate = true;
            plane.geometry.computeVertexNormals();

            // Also update the kernel preview
            drawKernelPreview(sigma);
        }

        // --- Event Listeners ---
        sigmaSlider.addEventListener('input', updateSurface);
        axisSizeSlider.addEventListener('input', () => {
            size = parseInt(axisSizeSlider.value);

            // Recreate grid
            scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(size, size * 5, '#475569', '#334155');
            gridHelper.position.y = 0.001;
            scene.add(gridHelper);

            // Recreate plane geometry
            plane.geometry.dispose();
            plane.geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            originalPositions = plane.geometry.attributes.position.clone();

            // Redraw everything
            updateLabels();
            updateSurface();
        });

        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Initial Call ---
        updateSurface();
        animate();
    </script>

</body>
</html>