<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Image Channel Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #e5e7eb;
        }
        /* Custom file input button */
        .file-input-button {
            cursor: pointer;
            display: inline-block;
            text-align: center;
        }
        canvas {
            background-color: #1f2937;
            border-radius: 0.5rem;
            border: 1px solid #374151;
        }
        .canvas-container {
            position: relative;
        }
        .tooltip {
            position: absolute;
            display: none;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.875rem;
            pointer-events: none;
            transform: translate(-50%, -120%);
            transition: opacity 0.2s;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -20px;
            margin-left: -20px;
            z-index: 10;
            display: none; /* Hidden by default */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="antialiased">
    <div class="min-h-screen p-4 sm:p-6 lg:p-8">
        <div class="max-w-7xl mx-auto">
            <!-- Header Section -->
            <header class="text-center mb-8">
                <h1 class="text-3xl sm:text-4xl font-bold tracking-tight text-white">Interactive Image Channel Explorer</h1>
                <p class="mt-2 text-lg text-gray-400">Upload an image to see its Red, Green, and Blue channels, along with their histograms.</p>
            </header>

            <!-- Controls Section -->
            <div class="flex justify-center items-center space-x-4 mb-8">
                <label for="imageUpload" class="file-input-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    Upload Image
                </label>
                <input type="file" id="imageUpload" class="hidden" accept="image/*">
                <button id="resetButton" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    Use Default
                </button>
            </div>

            <!-- Main Content Area -->
            <main class="space-y-12">
                <!-- Image Canvases Section -->
                <section class="bg-gray-900/50 p-6 rounded-xl shadow-lg border border-gray-700">
                    <h2 class="text-2xl font-semibold mb-4 text-center">Image & Color Channels</h2>
                    <p class="text-center text-gray-400 mb-6 max-w-3xl mx-auto">An image is composed of separate channels for each primary color. Here, we split the original image into its Red, Green, and Blue components. The brighter a region is in a channel's image, the more of that color it contains.</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                        <!-- Original Image -->
                        <div class="text-center">
                            <h3 class="font-medium mb-2">Original</h3>
                            <div class="canvas-container aspect-w-1 aspect-h-1">
                                <canvas id="originalCanvas"></canvas>
                                <div id="loader" class="loader"></div>
                            </div>
                        </div>
                        <!-- Red Channel -->
                        <div class="text-center">
                            <h3 class="font-medium mb-2 text-red-400">Red Channel</h3>
                            <canvas id="redCanvas" class="aspect-w-1 aspect-h-1"></canvas>
                        </div>
                        <!-- Green Channel -->
                        <div class="text-center">
                            <h3 class="font-medium mb-2 text-green-400">Green Channel</h3>
                            <canvas id="greenCanvas" class="aspect-w-1 aspect-h-1"></canvas>
                        </div>
                        <!-- Blue Channel -->
                        <div class="text-center">
                            <h3 class="font-medium mb-2 text-blue-400">Blue Channel</h3>
                            <canvas id="blueCanvas" class="aspect-w-1 aspect-h-1"></canvas>
                        </div>
                    </div>
                </section>

                <!-- Histograms Section -->
                <section class="bg-gray-900/50 p-6 rounded-xl shadow-lg border border-gray-700">
                    <h2 class="text-2xl font-semibold mb-4 text-center">Color Histograms</h2>
                    <p class="text-center text-gray-400 mb-6 max-w-3xl mx-auto">A histogram shows the distribution of pixel intensities for each color channel. The x-axis represents brightness (0-255), and the y-axis shows the number of pixels at that brightness. Hover over the bars to see details.</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <!-- Original Histogram -->
                        <div class="text-center">
                            <h3 class="font-medium mb-2">Overall Histogram</h3>
                            <div class="canvas-container">
                                <canvas id="originalHistogram" height="200"></canvas>
                                <div id="originalTooltip" class="tooltip"></div>
                            </div>
                        </div>
                        <!-- Red Histogram -->
                        <div class="text-center">
                            <h3 class="font-medium mb-2 text-red-400">Red Histogram</h3>
                            <div class="canvas-container">
                                <canvas id="redHistogram" height="200"></canvas>
                                <div id="redTooltip" class="tooltip"></div>
                            </div>
                        </div>
                        <!-- Green Histogram -->
                        <div class="text-center">
                            <h3 class="font-medium mb-2 text-green-400">Green Histogram</h3>
                            <div class="canvas-container">
                                <canvas id="greenHistogram" height="200"></canvas>
                                <div id="greenTooltip" class="tooltip"></div>
                            </div>
                        </div>
                        <!-- Blue Histogram -->
                        <div class="text-center">
                            <h3 class="font-medium mb-2 text-blue-400">Blue Histogram</h3>
                            <div class="canvas-container">
                                <canvas id="blueHistogram" height="200"></canvas>
                                <div id="blueTooltip" class="tooltip"></div>
                            </div>
                        </div>
                    </div>
                </section>
            </main>

            <!-- Footer Section -->
            <footer class="text-center mt-12 mb-4">
                <button onclick="history.back()" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    Go Back
                </button>
            </footer>

        </div>
    </div>

    <script>
        // --- Canvas and DOM Element Setup ---
        const originalCanvas = document.getElementById('originalCanvas');
        const redCanvas = document.getElementById('redCanvas');
        const greenCanvas = document.getElementById('greenCanvas');
        const blueCanvas = document.getElementById('blueCanvas');
        
        const originalHistogramCanvas = document.getElementById('originalHistogram');
        const redHistogramCanvas = document.getElementById('redHistogram');
        const greenHistogramCanvas = document.getElementById('greenHistogram');
        const blueHistogramCanvas = document.getElementById('blueHistogram');

        const imageUpload = document.getElementById('imageUpload');
        const resetButton = document.getElementById('resetButton');
        const loader = document.getElementById('loader');

        const canvases = [originalCanvas, redCanvas, greenCanvas, blueCanvas, originalHistogramCanvas, redHistogramCanvas, greenHistogramCanvas, blueHistogramCanvas];
        const contexts = canvases.map(c => c.getContext('2d', { willReadFrequently: true }));
        const [originalCtx, redCtx, greenCtx, blueCtx, originalHistCtx, redHistCtx, greenHistCtx, blueHistCtx] = contexts;

        // Default image URL
        const defaultImageUrl = 'https://images.pexels.com/photos/167699/pexels-photo-167699.jpeg?auto=compress&cs=tinysrgb&w=800';

        // --- Image Processing and Drawing ---

        function loadImage(src) {
            loader.style.display = 'block';
            const img = new Image();
            img.crossOrigin = "Anonymous"; // Handle CORS for external images
            img.onload = () => {
                // Resize canvases to match image aspect ratio
                const aspectRatio = img.naturalWidth / img.naturalHeight;
                canvases.forEach(canvas => {
                    if (canvas.id.includes('Canvas')) { // Only resize image canvases
                        const parentWidth = canvas.parentElement.clientWidth;
                        canvas.width = parentWidth;
                        canvas.height = parentWidth / aspectRatio;
                    }
                });
                originalCtx.drawImage(img, 0, 0, originalCanvas.width, originalCanvas.height);
                processImage();
                loader.style.display = 'none';
            };
            img.onerror = () => {
                alert('Failed to load image. Please try a different one.');
                loader.style.display = 'none';
            }
            img.src = src;
        }

        function processImage() {
            if (!originalCanvas.width || !originalCanvas.height) return;

            // Get image data from the original canvas
            const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
            const data = imageData.data;

            // Create new image data objects for each channel
            const redImageData = redCtx.createImageData(originalCanvas.width, originalCanvas.height);
            const greenImageData = greenCtx.createImageData(originalCanvas.width, originalCanvas.height);
            const blueImageData = blueCtx.createImageData(originalCanvas.width, originalCanvas.height);

            // Initialize histogram arrays (0-255)
            const redHistogram = new Array(256).fill(0);
            const greenHistogram = new Array(256).fill(0);
            const blueHistogram = new Array(256).fill(0);

            // Iterate over each pixel
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];

                // Populate histogram data
                redHistogram[r]++;
                greenHistogram[g]++;
                blueHistogram[b]++;
                
                // --- Populate Red Channel Image Data ---
                // Set R, G=0, B=0, A
                redImageData.data[i] = r;
                redImageData.data[i + 1] = 0;
                redImageData.data[i + 2] = 0;
                redImageData.data[i + 3] = a;

                // --- Populate Green Channel Image Data ---
                // Set R=0, G, B=0, A
                greenImageData.data[i] = 0;
                greenImageData.data[i + 1] = g;
                greenImageData.data[i + 2] = 0;
                greenImageData.data[i + 3] = a;

                // --- Populate Blue Channel Image Data ---
                // Set R=0, G=0, B, A
                blueImageData.data[i] = 0;
                blueImageData.data[i + 1] = 0;
                blueImageData.data[i + 2] = b;
                blueImageData.data[i + 3] = a;
            }

            // Draw the channel images to their canvases
            redCtx.putImageData(redImageData, 0, 0);
            greenCtx.putImageData(greenImageData, 0, 0);
            blueCtx.putImageData(blueImageData, 0, 0);

            // Draw the histograms
            drawCombinedHistogram(originalHistCtx, redHistogram, greenHistogram, blueHistogram);
            drawHistogram(redHistCtx, redHistogram, '#ef4444'); // Red
            drawHistogram(greenHistCtx, greenHistogram, '#22c55e'); // Green
            drawHistogram(blueHistCtx, blueHistogram, '#3b82f6'); // Blue
        }

        function drawCombinedHistogram(ctx, redData, greenData, blueData) {
            const canvas = ctx.canvas;
            canvas.width = canvas.parentElement.clientWidth;
            const width = canvas.width;
            const height = canvas.height;
            
            const padding = { top: 20, right: 20, bottom: 40, left: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            const barWidth = chartWidth / 256;

            const maxVal = Math.max(...redData, ...greenData, ...blueData);
            if (maxVal === 0) return;

            ctx.clearRect(0, 0, width, height);

            // --- Draw Axes and Labels ---
            ctx.strokeStyle = '#9ca3af';
            ctx.fillStyle = '#d1d5db';
            ctx.font = '12px Inter';
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();

            ctx.save();
            ctx.translate(padding.left / 2 - 10, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Pixel Frequency', 0, 0);
            ctx.restore();

            ctx.textAlign = 'center';
            ctx.fillText('Intensity Value', padding.left + chartWidth / 2, height - 10);

            ctx.textAlign = 'center';
            ctx.fillText('0', padding.left, height - padding.bottom + 15);
            ctx.fillText('128', padding.left + chartWidth / 2, height - padding.bottom + 15);
            ctx.fillText('255', width - padding.right, height - padding.bottom + 15);

            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText('0', padding.left - 8, height - padding.bottom);
            ctx.fillText(maxVal.toLocaleString(), padding.left - 8, padding.top);

            // --- Draw Histogram Bars ---
            const channels = [
                { data: redData, color: 'rgba(239, 68, 68, 0.7)' },
                { data: greenData, color: 'rgba(34, 197, 94, 0.7)' },
                { data: blueData, color: 'rgba(59, 130, 246, 0.7)' }
            ];

            channels.forEach(channel => {
                ctx.fillStyle = channel.color;
                for (let i = 0; i < 256; i++) {
                    const barHeight = (channel.data[i] / maxVal) * chartHeight;
                    if (barHeight > 0) {
                        ctx.fillRect(padding.left + (i * barWidth), height - padding.bottom - barHeight, barWidth, barHeight);
                    }
                }
            });
        }

        function drawHistogram(ctx, histogramData, color) {
            const canvas = ctx.canvas;
            canvas.width = canvas.parentElement.clientWidth;
            const width = canvas.width;
            const height = canvas.height;

            const padding = { top: 20, right: 20, bottom: 40, left: 60 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            const barWidth = chartWidth / 256;
            
            const maxVal = Math.max(...histogramData);
            
            ctx.clearRect(0, 0, width, height);

            // --- Draw Axes and Labels ---
            ctx.strokeStyle = '#9ca3af';
            ctx.fillStyle = '#d1d5db';
            ctx.font = '12px Inter';
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();

            ctx.save();
            ctx.translate(padding.left / 2 - 10, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Pixel Frequency', 0, 0);
            ctx.restore();

            ctx.textAlign = 'center';
            ctx.fillText('Intensity Value', padding.left + chartWidth / 2, height - 10);

            ctx.textAlign = 'center';
            ctx.fillText('0', padding.left, height - padding.bottom + 15);
            ctx.fillText('128', padding.left + chartWidth / 2, height - padding.bottom + 15);
            ctx.fillText('255', width - padding.right, height - padding.bottom + 15);

            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText('0', padding.left - 8, height - padding.bottom);
            if (maxVal > 0) {
                ctx.fillText(maxVal.toLocaleString(), padding.left - 8, padding.top);
            }
            
            // --- Draw Histogram Bars ---
            ctx.fillStyle = color;
            if (maxVal > 0) {
                for (let i = 0; i < 256; i++) {
                    const barHeight = (histogramData[i] / maxVal) * chartHeight;
                    ctx.fillRect(padding.left + (i * barWidth), height - padding.bottom - barHeight, barWidth, barHeight);
                }
            }
        }
        
        // --- Interactivity and Event Listeners ---

        function setupHistogramTooltip(canvasId, tooltipId, histogramData, colorName) {
            const canvas = document.getElementById(canvasId);
            const tooltip = document.getElementById(tooltipId);
            const padding = { left: 60, right: 20 };

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                const chartWidth = canvas.width - padding.left - padding.right;
                const barWidth = chartWidth / 256;

                if (x >= padding.left && x <= canvas.width - padding.right) {
                    const chartX = x - padding.left;
                    const index = Math.floor(chartX / barWidth);
                    
                    if (index >= 0 && index < 256) {
                        const value = histogramData[index];
                        tooltip.style.display = 'block';
                        tooltip.style.left = `${e.clientX - rect.left}px`;
                        tooltip.style.top = `${e.clientY - rect.top}px`;
                        tooltip.innerHTML = `Level ${index}<br>${colorName}: ${value.toLocaleString()} pixels`;
                    }
                } else {
                    tooltip.style.display = 'none';
                }
            });

            canvas.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });
        }
        
        function setupCombinedHistogramTooltip(canvasId, tooltipId, redData, greenData, blueData) {
            const canvas = document.getElementById(canvasId);
            const tooltip = document.getElementById(tooltipId);
            const padding = { left: 60, right: 20 };

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                const chartWidth = canvas.width - padding.left - padding.right;
                const barWidth = chartWidth / 256;
                
                if (x >= padding.left && x <= canvas.width - padding.right) {
                    const chartX = x - padding.left;
                    const index = Math.floor(chartX / barWidth);
                    
                    if (index >= 0 && index < 256) {
                        const redValue = redData[index];
                        const greenValue = greenData[index];
                        const blueValue = blueData[index];
                        tooltip.style.display = 'block';
                        tooltip.style.left = `${e.clientX - rect.left}px`;
                        tooltip.style.top = `${e.clientY - rect.top}px`;
                        tooltip.innerHTML = `Level ${index}<br>
                                        <span style="color:#ef4444;">R: ${redValue.toLocaleString()}</span><br>
                                        <span style="color:#22c55e;">G: ${greenValue.toLocaleString()}</span><br>
                                        <span style="color:#3b82f6;">B: ${blueValue.toLocaleString()}</span>`;
                    }
                } else {
                    tooltip.style.display = 'none';
                }
            });

            canvas.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });
        }

        // Re-run histogram tooltips setup after processing
        function setupAllTooltips() {
             // We need to re-calculate histograms to pass the data to the tooltips
            const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
            const data = imageData.data;
            const redHistogram = new Array(256).fill(0);
            const greenHistogram = new Array(256).fill(0);
            const blueHistogram = new Array(256).fill(0);
            for (let i = 0; i < data.length; i += 4) {
                redHistogram[data[i]]++;
                greenHistogram[data[i+1]]++;
                blueHistogram[data[i+2]]++;
            }
            setupCombinedHistogramTooltip('originalHistogram', 'originalTooltip', redHistogram, greenHistogram, blueHistogram);
            setupHistogramTooltip('redHistogram', 'redTooltip', redHistogram, 'Red');
            setupHistogramTooltip('greenHistogram', 'greenTooltip', greenHistogram, 'Green');
            setupHistogramTooltip('blueHistogram', 'blueTooltip', blueHistogram, 'Blue');
        }
        
        // We need to override processImage to include the tooltip setup
        const originalProcessImage = processImage;
        processImage = function() {
            originalProcessImage();
            setupAllTooltips();
        }

        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadImage(event.target.result);
                };
                reader.readAsDataURL(file);
            }
        });

        resetButton.addEventListener('click', () => {
            loadImage(defaultImageUrl);
        });
        
        // Initial load
        window.addEventListener('load', () => {
            loadImage(defaultImageUrl);
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            // A simple approach: reload the current image to redraw on resized canvases
            if (originalCanvas.width > 0) {
                 loadImage(originalCanvas.toDataURL());
            }
        });

    </script>
</body>
</html>

