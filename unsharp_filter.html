<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unsharp Filter – Interactive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .canvas-container { position: relative; display: inline-block; }
    </style>
    <meta name="description" content="Interactive visualization of the Unsharp Filter (Unsharp Masking) for image sharpening.">
</head>
<body class="bg-gradient-to-br from-slate-900 via-indigo-900 to-slate-900 text-white min-h-screen">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold bg-gradient-to-r from-indigo-300 to-purple-400 bg-clip-text text-transparent">
                Unsharp Filter
            </h1>
            <p class="mt-4 text-lg text-slate-300 max-w-3xl mx-auto">
                Sharpen an image by subtracting a blurred version of it from the original to create an "unsharp mask," then adding the mask back.
            </p>
        </header>

        <!-- Educational Section -->
        <section class="mb-8 bg-slate-800/50 backdrop-blur-sm rounded-2xl p-6 border border-slate-700">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div>
                    <h2 class="text-2xl font-semibold text-sky-300 mb-4">How It Works</h2>
                    <div class="space-y-4 text-slate-300">
                        <p>
                            Unsharp masking is a multi-step process. First, a blurred (or "unsharp") copy of the original image is created. This blurred copy is then subtracted from the original, which results in a mask containing only the high-frequency details (edges). Finally, this mask is scaled by an "amount" and added back to the original image.
                        </p>
                        <div class="bg-slate-900/70 p-4 rounded-lg border border-slate-600">
                            <h3 class="text-lg font-medium text-slate-200 mb-2">The Formula</h3>
                            <p class="text-center text-md font-mono text-cyan-300">Sharpened = Original + Amount × (Original - Blurred)</p>
                            <ul class="list-disc list-inside space-y-1 text-slate-300 mt-2 text-sm">
                                <li><strong>Blurred</strong> is typically a Gaussian blur of the original.</li>
                                <li><strong>(Original - Blurred)</strong> is the "unsharp mask".</li>
                                <li><strong>Amount</strong> controls the strength of the sharpening effect.</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div>
                    <h2 class="text-2xl font-semibold text-emerald-300 mb-4">Common Uses</h2>
                    <div class="space-y-3 text-slate-300">
                        <div class="flex items-start space-x-3">
                            <div class="w-2 h-2 bg-emerald-300 rounded-full mt-2 flex-shrink-0"></div>
                            <p><strong>Photo Sharpening:</strong> The standard method for sharpening digital photographs to enhance details.</p>
                        </div>
                        <div class="flex items-start space-x-3">
                            <div class="w-2 h-2 bg-blue-300 rounded-full mt-2 flex-shrink-0"></div>
                            <p><strong>Detail Enhancement:</strong> Making fine textures and edges more prominent and clear.</p>
                        </div>
                        <div class="flex items-start space-x-3">
                            <div class="w-2 h-2 bg-purple-300 rounded-full mt-2 flex-shrink-0"></div>
                            <p><strong>Print Preparation:</strong> Compensating for the slight loss of sharpness that occurs during printing.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Controls and Previews -->
        <section class="mb-8">
            <div class="grid grid-cols-1 xl:grid-cols-3 gap-8">
                <!-- Controls + Kernel Preview -->
                <div class="bg-slate-800/50 backdrop-blur-sm rounded-2xl p-6 border border-slate-700">
                    <h3 class="text-xl font-semibold text-cyan-300 mb-4">Filter Settings</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-slate-300 mb-2">Blur Kernel Size: <span id="sizeVal" class="font-mono">3x3</span></label>
                            <input id="kernelSize" type="range" min="3" max="7" step="2" value="3" class="w-full accent-cyan-500 cursor-pointer">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-slate-300 mb-2">Blur Sigma (σ): <span id="sigmaVal" class="font-mono">1.0</span></label>
                            <input id="kernelSigma" type="range" min="0.5" max="3" step="0.1" value="1.0" class="w-full accent-cyan-500 cursor-pointer">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-slate-300 mb-2">Sharpen Amount: <span id="amountVal" class="font-mono">1.0</span></label>
                            <input id="sharpenAmount" type="range" min="0.1" max="3" step="0.1" value="1.0" class="w-full accent-cyan-500 cursor-pointer">
                        </div>
                        <div class="mt-4">
                            <h4 class="text-sm font-semibold text-slate-200 mb-2">Blur Kernel Preview</h4>
                            <div class="canvas-container">
                                <canvas id="kernelCanvas" width="220" height="220" class="border-2 border-slate-600 rounded-lg bg-slate-900"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Interactive Demonstration Grid -->
                <div class="bg-slate-800/50 backdrop-blur-sm rounded-2xl p-6 border border-slate-700 flex flex-col items-center xl:col-span-2">
                    <div class="flex items-center justify-between mb-4 w-full">
                        <h3 class="text-xl font-semibold text-indigo-400">Interactive Demonstration</h3>
                        <div class="flex space-x-2">
                            <button id="applyFilter" class="px-3 py-1 bg-indigo-600 hover:bg-indigo-700 rounded text-sm transition-colors">Apply Filter</button>
                            <button id="addNoise" class="px-3 py-1 bg-purple-600 hover:bg-purple-700 rounded text-sm transition-colors">Add Noise</button>
                            <button id="resetGrid" class="px-3 py-1 bg-slate-600 hover:bg-slate-700 rounded text-sm transition-colors">Reset Grid</button>
                        </div>
                    </div>
                    <div class="flex flex-col md:flex-row gap-6">
                        <div class="flex flex-col items-center">
                            <h4 class="text-lg font-semibold text-slate-300 mb-2">Input Grid</h4>
                            <div class="canvas-container">
                                <canvas id="demoCanvas" width="330" height="330" class="border-2 border-slate-600 rounded-lg cursor-pointer"></canvas>
                            </div>
                        </div>
                        <div class="flex flex-col items-center">
                            <h4 id="resultGridTitle" class="text-lg font-semibold text-indigo-300 mb-2">Result Grid</h4>
                            <div class="canvas-container">
                                <canvas id="resultDemoCanvas" width="330" height="330" class="border-2 border-indigo-500 rounded-lg"></canvas>
                            </div>
                        </div>
                    </div>
                    <p class="mt-3 text-sm text-slate-400 text-center">
                        Hover over the Input Grid to see the kernel and the resulting sharpened value.
                        <br>The result grid is grayscale to show the final values.
                    </p>
                </div>
            </div>
        </section>

        <!-- Back Button -->
        <div class="text-center">
            <button onclick="history.back()" class="bg-slate-700 hover:bg-slate-800 text-white font-bold py-3 px-8 rounded-lg transition-all duration-300 shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                ← Back to Gallery
            </button>
        </div>

    </div>

    <script>
        // Canvas and Contexts
        const kernelCanvas = document.getElementById('kernelCanvas');
        const kctx = kernelCanvas.getContext('2d');
        const demoCanvas = document.getElementById('demoCanvas');
        const dctx = demoCanvas.getContext('2d');
        const resultDemoCanvas = document.getElementById('resultDemoCanvas');
        const rdctx = resultDemoCanvas.getContext('2d');

        // Controls
        const kernelSize = document.getElementById('kernelSize');
        const sizeVal = document.getElementById('sizeVal');
        const kernelSigma = document.getElementById('kernelSigma');
        const sigmaVal = document.getElementById('sigmaVal');
        const sharpenAmount = document.getElementById('sharpenAmount');
        const amountVal = document.getElementById('amountVal');
        const applyFilter = document.getElementById('applyFilter');
        const addNoise = document.getElementById('addNoise');
        const resetGrid = document.getElementById('resetGrid');
        const resultGridTitle = document.getElementById('resultGridTitle');

        let currentKernel = [];

        function generateGaussianKernel(size, sigma) {
            const kernel = Array(size).fill(0).map(() => Array(size).fill(0));
            const r = Math.floor(size / 2);
            let sum = 0;

            for (let y = -r; y <= r; y++) {
                for (let x = -r; x <= r; x++) {
                    const exponent = -(x * x + y * y) / (2 * sigma * sigma);
                    const value = (1 / (2 * Math.PI * sigma * sigma)) * Math.exp(exponent);
                    kernel[y + r][x + r] = value;
                    sum += value;
                }
            }

            // Normalize the kernel
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    kernel[y][x] /= sum;
                }
            }
            return kernel;
        }

        // --- Demo Grid Logic ---
        const GRID_SIZE = 15;
        const CELL_SIZE = demoCanvas.width / GRID_SIZE;
        let gridState = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
        let originalGridState = null;
        let hoverPos = null;

        function initDemoGrid() {
            // Create a sharp edge shape
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    gridState[y][x] = (x < GRID_SIZE / 2) ? 1 : 0;
                }
            }
            gridState[7][3] = 0; // Add a small detail
            gridState[7][11] = 1;
            originalGridState = JSON.parse(JSON.stringify(gridState));
            drawDemoGrid();
            drawResultGrid(gridState);
        }

        function drawResultGrid(state) {
            rdctx.fillStyle = '#0f172a';
            rdctx.fillRect(0, 0, resultDemoCanvas.width, resultDemoCanvas.height);
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const value = Math.round(Math.max(0, Math.min(1, state[y][x])) * 255);
                    rdctx.fillStyle = `rgb(${value}, ${value}, ${value})`;
                    rdctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                }
            }
        }

        function drawDemoGrid(gridForCheck) {
            const checkGrid = gridForCheck || gridState;
            dctx.fillStyle = '#0f172a';
            dctx.fillRect(0, 0, demoCanvas.width, demoCanvas.height);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    dctx.fillStyle = gridState[y][x] ? '#e2e8f0' : '#1e293b';
                    dctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                }
            }

            if (hoverPos) {
                const hx = hoverPos.x;
                const hy = hoverPos.y;
                const size = currentKernel.length;
                const r = Math.floor(size / 2);
                let blurredValue = 0;

                for (let j = -r; j <= r; j++) {
                    for (let i = -r; i <= r; i++) {
                        const kx = hx + i;
                        const ky = hy + j;
                        if (kx >= 0 && kx < GRID_SIZE && ky >= 0 && ky < GRID_SIZE) {
                            const weight = currentKernel[j + r][i + r];
                            blurredValue += checkGrid[ky][kx] * weight;
                            
                            dctx.fillStyle = 'rgba(99, 102, 241, 0.5)'; // indigo-500 with alpha
                            dctx.fillRect(kx * CELL_SIZE, ky * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }

                dctx.strokeStyle = '#eab308';
                dctx.lineWidth = 2;
                dctx.strokeRect(hx * CELL_SIZE + 1, hy * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);

                const originalValue = checkGrid[hy][hx];
                const mask = originalValue - blurredValue;
                const amount = parseFloat(sharpenAmount.value);
                const finalValue = originalValue + amount * mask;

                const resultValue = Math.round(Math.max(0, Math.min(1, finalValue)) * 255);
                const resultColor = `rgb(${resultValue}, ${resultValue}, ${resultValue})`;

                dctx.fillStyle = resultColor;
                dctx.globalAlpha = 0.7;
                dctx.fillRect(hx * CELL_SIZE + 1, hy * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                dctx.globalAlpha = 1.0;

                dctx.strokeStyle = '#10b981';
                dctx.lineWidth = 3;
                dctx.strokeRect(hx * CELL_SIZE, hy * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }

        demoCanvas.addEventListener('mousemove', (e) => {
            const rect = demoCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const gridX = Math.floor(mouseX / CELL_SIZE);
            const gridY = Math.floor(mouseY / CELL_SIZE);

            if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                if (!hoverPos || hoverPos.x !== gridX || hoverPos.y !== gridY) {
                    hoverPos = { x: gridX, y: gridY };
                    drawDemoGrid();
                }
            } else {
                hoverPos = null;
                drawDemoGrid();
            }
        });

        demoCanvas.addEventListener('mouseleave', () => {
            hoverPos = null;
            drawDemoGrid();
        });

        demoCanvas.addEventListener('click', (e) => {
            const rect = demoCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const gridX = Math.floor(mouseX / CELL_SIZE);
            const gridY = Math.floor(mouseY / CELL_SIZE);

            if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                gridState[gridY][gridX] = 1 - gridState[gridY][gridX];
                originalGridState[gridY][gridX] = gridState[gridY][gridX];
                drawResultGrid(gridState);
                drawDemoGrid();
            }
        });

        addNoise.addEventListener('click', () => {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const rand = Math.random();
                    if (rand < 0.1) { gridState[y][x] = 1; } 
                    else if (rand > 0.9) { gridState[y][x] = 0; }
                }
            }
            originalGridState = JSON.parse(JSON.stringify(gridState));
            drawDemoGrid();
            drawResultGrid(gridState);
        });

        applyFilter.addEventListener('click', async () => {
            const controlsToToggle = [applyFilter, resetGrid, kernelSize, kernelSigma, sharpenAmount, demoCanvas, addNoise];
            controlsToToggle.forEach(el => el.disabled = true);
            demoCanvas.style.cursor = 'wait';

            let currentGrid = JSON.parse(JSON.stringify(originalGridState));
            
            // --- Step 1: Blur the image ---
            resultGridTitle.textContent = `Blurring...`;
            const blurredGrid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            const size = parseInt(kernelSize.value, 10);
            const r = Math.floor(size / 2);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    let weightedSum = 0;
                    for (let j = -r; j <= r; j++) {
                        for (let i = -r; i <= r; i++) {
                            const kx = x + i;
                            const ky = y + j;
                            if (kx >= 0 && kx < GRID_SIZE && ky >= 0 && ky < GRID_SIZE) {
                                const weight = currentKernel[j + r][i + r];
                                weightedSum += currentGrid[ky][kx] * weight;
                            }
                        }
                    }
                    blurredGrid[y][x] = weightedSum;
                }
            }
            drawResultGrid(blurredGrid);
            await new Promise(r => setTimeout(r, 800));

            // --- Step 2: Create and apply mask ---
            resultGridTitle.textContent = `Sharpening...`;
            const finalGrid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            const amount = parseFloat(sharpenAmount.value);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    hoverPos = { x, y };
                    drawDemoGrid(currentGrid);

                    const originalValue = currentGrid[y][x];
                    const blurredValue = blurredGrid[y][x];
                    const mask = originalValue - blurredValue;
                    const finalValue = originalValue + amount * mask;
                    finalGrid[y][x] = finalValue;

                    const resultValue = Math.round(Math.max(0, Math.min(1, finalValue)) * 255);
                    rdctx.fillStyle = `rgb(${resultValue}, ${resultValue}, ${resultValue})`;
                    rdctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                    await new Promise(r => setTimeout(r, 10));
                }
            }

            controlsToToggle.forEach(el => el.disabled = false);
            demoCanvas.style.cursor = 'pointer';
            hoverPos = null;
            resultGridTitle.textContent = 'Result Grid';
            drawDemoGrid(finalGrid);
        });

        resetGrid.addEventListener('click', () => {
            gridState = JSON.parse(JSON.stringify(originalGridState));
            drawResultGrid(gridState);
            drawDemoGrid();
        });

        function renderKernel() {
            const size = parseInt(kernelSize.value, 10);
            const sigma = parseFloat(kernelSigma.value);
            currentKernel = generateGaussianKernel(size, sigma);

            const pad = 10;
            const cellSize = Math.floor((kernelCanvas.width - pad * 2) / size);
            kctx.fillStyle = '#0f172a';
            kctx.fillRect(0, 0, kernelCanvas.width, kernelCanvas.height);

            const maxWeight = currentKernel[Math.floor(size/2)][Math.floor(size/2)];

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const cx = pad + x * cellSize;
                    const cy = pad + y * cellSize;
                    const weight = currentKernel[y][x];
                    const intensity = Math.round((weight / maxWeight) * 255);
                    
                    kctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                    kctx.fillRect(cx, cy, cellSize - 2, cellSize - 2);
                }
            }
        }

        function updateAndRender() {
            sizeVal.textContent = `${kernelSize.value}x${kernelSize.value}`;
            sigmaVal.textContent = parseFloat(kernelSigma.value).toFixed(1);
            amountVal.textContent = parseFloat(sharpenAmount.value).toFixed(1);
            renderKernel();
            drawDemoGrid();
        }

        kernelSize.addEventListener('input', updateAndRender);
        kernelSigma.addEventListener('input', updateAndRender);
        sharpenAmount.addEventListener('input', updateAndRender);

        // Initialize
        initDemoGrid();
        updateAndRender();
    </script>

</body>
</html>